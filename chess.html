<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chess Engine</title>
  <link href="data:image/x-icon;base64,AAABAAEAEBACAAAAAACwAAAAFgAAACgAAAAQAAAAIAAAAAEAAQAAAAAAQAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAA////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAACQAAAAAAAAAAAAADwDwAA+B8AAPw/AADsNwAAzDMAAMQjAADkJwAA4AcAAPAPAAD4HwAA8A8AAPAPAADwDwAA8A8AAPAPAADwDwAA" rel="icon" type="image/x-icon" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
	body { font-family: 'Roboto', sans-serif; }
	.board, .info { width: 400px; margin: auto; }
	.move-history { height: auto; overflow-y: visible; }
	#loading-bar, #score { margin: 20px auto; text-align: center; font-size: 18px; }
	.loader { border: 8px solid #f3f3f3; border-top: 8px solid #3498db; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; }
	@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
	.clearfix-7da63 { clear: both; }
	.board-b72b1 { border: 2px solid #404040; -moz-box-sizing: content-box; box-sizing: content-box; }
	.square-55d63 { float: left; position: relative; user-select: none; }
	.white-1e1d7 { background-color: #f0d9b5; color: #b58863; }
	.black-3c85d { background-color: #b58863; color: #f0d9b5; }
	.highlight1-32417, .highlight2-9c5d2 { box-shadow: inset 0 0 3px 3px yellow; background-color: yellow; }
	.allowed-move { background-color: rgba(255, 255, 0, 0.5); }
	.notation-322f9 { cursor: default; font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; font-size: 14px; position: absolute; }
	.alpha-d2270 { bottom: 1px; right: 3px; }
	.numeric-fc462 { top: 2px; left: 2px; }
  </style>
  <script>
    window.console = window.console || function (t) {};
  </script>
  <base href="https://chessboardjs.com/" />
</head>
<body translate="no">
  
  <center>
    <h3 class="board">
      Chess Engine
    </h3>
    <div id="score">Rating: N/A</div>
    <div id="loading-bar">Welcome</div>
    <br>
	<div id="board" class="board"></div>
    <br>
  </center>
  <div class="info">
    <div id="move-history" class="move-history"></div>
  </div>
  <script src='https://code.jquery.com/jquery-2.2.4.min.js'></script>
  <script src='https://cdn.rawgit.com/lhartikk/simple-chess-ai/master/lib/js/chess.js'></script>
  <script src='https://chessboardjs.com/js/chessboard.js'></script>
  <script id="rendered-js">
    var board,
      game = new Chess();
    var lastComputerMove = null; 
    var pieceValues = {
      'p': 100,
      'n': 300,
      'b': 300,
      'r': 500,
      'q': 900,
    };
    var calculateBestMove = function (game) {
      var bestMove = null;
      var bestValue = -Infinity;
      for (var move of game.ugly_moves()) {
        game.ugly_move(move);
        var boardValue = -minimax(game, 3, -Infinity, Infinity);
        game.undo();

        if (boardValue > bestValue) {
          bestValue = boardValue;
          bestMove = move;
        }
      }
      return bestMove;
    };

    var minimax = function (game, depth, alpha, beta) {
      if (depth === 0 || game.game_over()) {
        return evaluateBoard(game);
      }

      var moves = game.ugly_moves();
      if (game.turn() === 'w') {
        let maxEval = -Infinity;
        for (var move of moves) {
          game.ugly_move(move);
          let eval = minimax(game, depth - 1, alpha, beta);
          game.undo();
          maxEval = Math.max(maxEval, eval);
          alpha = Math.max(alpha, eval);
          if (beta <= alpha) {
            break; 
          }
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (var move of moves) {
          game.ugly_move(move);
          let eval = minimax(game, depth - 1, alpha, beta);
          game.undo();
          minEval = Math.min(minEval, eval);
          beta = Math.min(beta, eval);
          if (beta <= alpha) {
            break; 
          }
        }
        return minEval;
      }
    };

    var evaluateBoard = function (game) {
      var totalEvaluation = 0;
      for (var piece in pieceValues) {
        var pieceCount = game.board().reduce((count, row) => {
          return count + row.reduce((count, square) => {
            return count + (square && square.type === piece ? (square.color === 'w' ? 1 : -1) : 0);
          }, 0);
        }, 0);
        totalEvaluation += pieceCount * pieceValues[piece];
      }
      updateScore(totalEvaluation);
      return totalEvaluation;
    };

    var updateScore = function (score) {

      const maxScore = 1000; 
      const minScore = -1000; 
      let normalizedScore = Math.max(minScore, Math.min(maxScore, score)); 
      let whiteScore = ((normalizedScore + maxScore) / (2 * maxScore)) * 100; 
      let blackScore = ((maxScore - normalizedScore) / (2 * maxScore)) * 100; 
      const totalScore = whiteScore + blackScore;
      whiteScore = (whiteScore / totalScore) * 100;
      blackScore = (blackScore / totalScore) * 100;

      $('#score').text(`White: ${whiteScore.toFixed(1)}% | Black: ${blackScore.toFixed(1)}%`);
    };

    var onDragStart = function (source, piece, position, orientation) {
      if (game.in_checkmate() === true || game.in_draw() === true ||
        piece.search(/^b/) !== -1) {
        return false;
      }
    };

    var highlightAllowedMoves = function (piece) {
      const moves = game.moves({
        square: piece,
        verbose: true
      });

      for (let move of moves) {
        addAllowedMoveHighlight(move.to);
      }
    };

    var makeBestMove = function () {
      $('#loading-bar').text('Computer is thinking...') 

      window.setTimeout(function () {
        var bestMove = calculateBestMove(game);
        game.ugly_move(bestMove);
        lastComputerMove = bestMove; 
        board.position(game.fen());
        renderMoveHistory(game.history());

        $('#loading-bar').text('Your turn!') 
      }, 250);
    };

    var addAllowedMoveHighlight = function (square) {
      const squareEl = $('#board .square-' + square);
      squareEl.addClass('allowed-move');
      setTimeout(function () {
        squareEl.removeClass('allowed-move');
      }, 1000);
    };

    var greySquare = function (square) {
      const squareEl = $('#board .square-' + square);

      squareEl.addClass('highlight1-32417');
      setTimeout(function () {
        squareEl.removeClass('highlight1-32417');
      }, 1000);
    };

    var renderMoveHistory = function (moves) {
      var moveHistoryElement = $('#move-history');
      moveHistoryElement.empty();
      for (var i = 0; i < moves.length; i = i + 2) {
        moveHistoryElement.append('<span><b>' + (i/2 + 1) + '.</b> ' + moves[i] + ' ' + (moves[i + 1] ? moves[i + 1] : '') + ' </span>')
      }
      moveHistoryElement.scrollTop(moveHistoryElement[0].scrollHeight);
    };

    var onDrop = function (source, target) {
      removeGreySquares();
      var move = game.move({
        from: source,
        to: target,
        promotion: 'q'
      });

      if (move === null) return 'snapback';

      renderMoveHistory(game.history());
      updateScore(evaluateBoard(game));

      if (game.game_over()) {
        moveHistoryElement.append(' Game over.');
      } else {
        makeBestMove();
      }
    };

    var onSnapEnd = function () {
      board.position(game.fen());
    };

    var removeGreySquares = function () {
      $('#board .square-55d63').removeClass('allowed-move');
    };

    var onMouseoutSquare = function (square) {
      removeGreySquares();
    };

    var onClickSquare = function (square) {
      removeGreySquares();
      highlightAllowedMoves(square); 
    };

    var cfg = {
      draggable: true,
      position: 'start',
      onDragStart: onDragStart,
      onDrop: onDrop,
      onMouseoutSquare: onMouseoutSquare,
      onClickSquare: onClickSquare,
      onSnapEnd: onSnapEnd,
      onChange: onChange,
    };

    board = ChessBoard('board', cfg);

    function onChange() {
      
      const pieceSquare = game.history().length > 0 ? game.history()[game.history().length - 1].to : null;
      if (pieceSquare) {
        highlightAllowedMoves(pieceSquare);
      }
    }
  </script>
</body>

</html>
